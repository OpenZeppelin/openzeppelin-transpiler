# Snapshot report for `src/transform.test.ts`

The actual snapshot is saved in `transform.test.ts.snap`.

Generated by [AVA](https://avajs.dev).

## remove functions

> Snapshot 1

    `pragma solidity ^0.6;␊
    ␊
    contract RemoveFunctions {␊
        ␊
        ␊
    }␊
    `

## rename identifiers

> Snapshot 1

    `pragma solidity ^0.6.0;␊
    ␊
    library RenameLibrary {␊
        function test() external {␊
        }␊
    }␊
    ␊
    contract RenameContract {␊
    }␊
    ␊
    contract RenameDeployer {␊
        RenameContractUpgradeable rc = RenameContractUpgradeable(0);␊
    ␊
        constructor() public {␊
            new RenameContractUpgradeable();␊
        }␊
    ␊
        function deploy() external returns (RenameContractUpgradeable) {␊
            return new RenameContractUpgradeable();␊
        }␊
    ␊
        function test() external {␊
            RenameLibraryUpgradeable.test();␊
        }␊
    }␊
    `

## prepend Initializable base

> Snapshot 1

    `pragma solidity ^0.6.0;␊
    ␊
    library RenameLibrary {␊
        function test() external {␊
        }␊
    }␊
    ␊
    contract RenameContract is Initializable {␊
    }␊
    ␊
    contract RenameDeployer is Initializable {␊
        RenameContract rc = RenameContract(0);␊
    ␊
        constructor() public {␊
            new RenameContract();␊
        }␊
    ␊
        function deploy() external returns (RenameContract) {␊
            return new RenameContract();␊
        }␊
    ␊
        function test() external {␊
            RenameLibrary.test();␊
        }␊
    }␊
    `

## purge var inits

> Snapshot 1

    `pragma solidity ^0.6.0;␊
    ␊
    contract ElementaryTypes  {␊
        address public owner;␊
        bool active;␊
        string hello;␊
        int count;␊
        uint ucount;␊
        bytes32 samevar;␊
        uint x;␊
        uint y;␊
    }␊
    `

## remove inheritance args

> Snapshot 1

    `pragma solidity ^0.6;␊
    ␊
    contract A {␊
        constructor(uint) public {}␊
    }␊
    ␊
    contract B is A {␊
    ␊
        modifier hasModifier (){␊
            _;␊
        }␊
        ␊
        modifier hasModifierArgument(uint b) {␊
            _;␊
        }␊
    ␊
        constructor (uint b) public hasModifier hasModifierArgument(b) {}␊
    }␊
    `

## transform contract name

> Snapshot 1

    `pragma solidity ^0.6.0;␊
    ␊
    library RenameLibraryUpgradeable {␊
        function test() external {␊
        }␊
    }␊
    ␊
    contract RenameContractUpgradeable {␊
    }␊
    ␊
    contract RenameDeployerUpgradeable {␊
        RenameContract rc = RenameContract(0);␊
    ␊
        constructor() public {␊
            new RenameContract();␊
        }␊
    ␊
        function deploy() external returns (RenameContract) {␊
            return new RenameContract();␊
        }␊
    ␊
        function test() external {␊
            RenameLibrary.test();␊
        }␊
    }␊
    `

## skip contract rename when Upgradeable suffix

> Snapshot 1

    `pragma solidity ^0.6.0;␊
    ␊
    contract AlreadyUpgradeable {␊
    }␊
    `

## fix import directives

> Snapshot 1

    `pragma solidity ^0.6.0;␊
    ␊
    import "./ImportedUpgradeable.sol";␊
    ␊
    contract Local is Imported2 {␊
        constructor(uint x, uint y) Imported2(x, y) public { }␊
    }␊
    `

## fix import directives complex

> Snapshot 1

    `pragma solidity ^0.6.0;␊
    ␊
    import { Imp1Upgradeable } from "./TransformImport2-ImportedUpgradeable.sol";␊
    import { Imp2Upgradeable as ImpX } from "./TransformImport2-ImportedUpgradeable.sol";␊
    ␊
    contract Foo {␊
        using Imp1Upgradeable for Imp1Upgradeable.S;␊
        using ImpX for ImpX.S;␊
    }␊
    `

## append initializable import

> Snapshot 1

    `pragma solidity ^0.6.0;␊
    ␊
    import './Imported.sol';␊
    import "./Initializable.sol";␊
    ␊
    contract Local is Imported2 {␊
        constructor(uint x, uint y) Imported2(x, y) public { }␊
    }␊
    `

## append initializable import custom

> Snapshot 1

    `pragma solidity ^0.6.0;␊
    ␊
    import './Imported.sol';␊
    import "./Initializable2.sol";␊
    ␊
    contract Local is Imported2 {␊
        constructor(uint x, uint y) Imported2(x, y) public { }␊
    }␊
    `

## transform constructor

> Snapshot 1

    `pragma solidity ^0.6;␊
    ␊
    contract Foo1 {␊
        function __Foo1_init() internal onlyInitializing {␊
        }␊
    ␊
        function __Foo1_init_unchained() internal onlyInitializing {␊
        }␊
    }␊
    ␊
    contract Foo2 {␊
        event Ev();␊
        function __Foo2_init() internal onlyInitializing {␊
            __Foo2_init_unchained();␊
        }␊
    ␊
        function __Foo2_init_unchained() internal onlyInitializing {␊
            emit Ev();␊
        }␊
    }␊
    ␊
    contract Foo3 {␊
        function __Foo3_init() internal onlyInitializing {␊
            __Foo3_init_unchained();␊
        }␊
    ␊
        function __Foo3_init_unchained() internal onlyInitializing {␊
            x = 1;␊
        }␊
        uint x = 1;␊
    }␊
    ␊
    contract Foo4 {␊
        uint x = 1;␊
        event Ev();␊
        function __Foo4_init() internal onlyInitializing {␊
            __Foo4_init_unchained();␊
        }␊
    ␊
        function __Foo4_init_unchained() internal onlyInitializing {␊
            x = 1;␊
            emit Ev();␊
        }␊
    }␊
    ␊
    contract Bar1 {␊
        function __Bar1_init() internal onlyInitializing {␊
        }␊
    ␊
        function __Bar1_init_unchained() internal onlyInitializing {␊
        }␊
    ␊
    }␊
    ␊
    contract Bar2 is Bar1 {␊
        function __Bar2_init() internal onlyInitializing {␊
        }␊
    ␊
        function __Bar2_init_unchained() internal onlyInitializing {␊
        }␊
    ␊
    }␊
    ␊
    contract Bar3 is Bar2 {␊
        function __Bar3_init() internal onlyInitializing {␊
        }␊
    ␊
        function __Bar3_init_unchained() internal onlyInitializing {␊
        }␊
    ␊
    }␊
    ␊
    contract Foo5 {␊
        function __Foo5_init(function () external f) internal onlyInitializing {␊
            __Foo5_init_unchained(f);␊
        }␊
    ␊
        function __Foo5_init_unchained(function () external f) internal onlyInitializing {␊
            f();␊
        }␊
    }␊
    ␊
    contract Foo6 {␊
        function __Foo6_init(␊
            uint a,␊
            uint b␊
        ) internal onlyInitializing {␊
            __Foo6_init_unchained(a, b);␊
        }␊
    ␊
        function __Foo6_init_unchained(␊
            uint a,␊
            uint b␊
        ) internal onlyInitializing {␊
            a = a + b;␊
        }␊
    }␊
    ␊
    contract Foo7 {␊
        uint a;␊
        function __Foo7_init(␊
            uint _a␊
        ) internal onlyInitializing {␊
            __Foo7_init_unchained(_a);␊
        }␊
    ␊
        function __Foo7_init_unchained(␊
            uint _a␊
        ) internal onlyInitializing {␊
            a = _a;␊
        }␊
    }␊
    ␊
    contract Foo8 {␊
    ␊
        modifier hasModifier() {␊
            _;␊
        }␊
    ␊
        function __Foo8_init() internal onlyInitializing {␊
            __Foo8_init_unchained();␊
        }␊
    ␊
        function __Foo8_init_unchained() internal onlyInitializing hasModifier {␊
        }␊
    }␊
    ␊
    contract Foo9 {␊
        function __Foo9_init(␊
            uint a,␊
            uint b␊
        ) internal onlyInitializing {␊
            __Foo9_init_unchained(a, b);␊
        }␊
    ␊
        function __Foo9_init_unchained(␊
            uint a,␊
            uint b␊
        ) internal onlyInitializing {␊
            a = 0;␊
            b = 0;␊
        }␊
    }␊
    ␊
    contract Foo10 is Foo7(123) {␊
        function __Foo10_init() internal onlyInitializing {␊
            __Foo7_init_unchained(123);␊
            __Foo10_init_unchained();␊
        }␊
    ␊
        function __Foo10_init_unchained() internal onlyInitializing {␊
            bar = 1;␊
        }␊
    ␊
        uint bar = 1;␊
    }␊
    ␊
    contract Foo11 is Foo7 {␊
    ␊
        modifier hasModifier() {␊
            _;␊
        }␊
    ␊
        function __Foo11_init(uint a) internal onlyInitializing {␊
            __Foo7_init_unchained(a);␊
            __Foo11_init_unchained(a);␊
        }␊
    ␊
        function __Foo11_init_unchained(uint) internal onlyInitializing hasModifier {␊
        }␊
    }␊
    ␊
    contract Foo12 is Foo7 {␊
    ␊
        function __Foo12_init(uint a) internal onlyInitializing {␊
            __Foo7_init_unchained(a);␊
        }␊
    ␊
        function __Foo12_init_unchained(uint) internal onlyInitializing {␊
        }␊
    }␊
    ␊
    contract Foo13 is Foo4 {␊
        function __Foo13_init() internal onlyInitializing {␊
            __Foo4_init_unchained();␊
        }␊
    ␊
        function __Foo13_init_unchained() internal onlyInitializing { }␊
    }␊
    ␊
    contract Foo14 is Foo7 {␊
    ␊
        modifier hasModifier(uint b) {␊
            _;␊
        }␊
    ␊
        function __Foo14_init(uint a, uint b) internal onlyInitializing {␊
            __Foo7_init_unchained(a);␊
            __Foo14_init_unchained(a, b);␊
        }␊
    ␊
        function __Foo14_init_unchained(uint, uint b) internal onlyInitializing hasModifier(b) {␊
        }␊
    }␊
    ␊
    contract Foo15 is Foo7 {␊
        uint x;␊
        function __Foo15_init(uint _x) internal onlyInitializing {␊
            __Foo7_init_unchained(_x);␊
            __Foo15_init_unchained(_x);␊
        }␊
    ␊
        function __Foo15_init_unchained(uint _x) internal onlyInitializing {␊
            x = _x;␊
        }␊
    }␊
    ␊
    abstract contract Foo16 is Foo15 {␊
        function __Foo16_init() internal onlyInitializing {␊
        }␊
    ␊
        function __Foo16_init_unchained() internal onlyInitializing {␊
        }␊
    ␊
    }␊
    ␊
    contract Foo17 is Foo4 {␊
        function __Foo17_init() internal onlyInitializing {␊
            __Foo4_init_unchained();␊
        }␊
    ␊
        function __Foo17_init_unchained() internal onlyInitializing {}␊
    }␊
    ␊
    abstract contract Foo18 is Foo17 {␊
        function __Foo18_init() internal onlyInitializing {␊
            __Foo4_init_unchained();␊
        }␊
    ␊
        function __Foo18_init_unchained() internal onlyInitializing {␊
        }␊
    ␊
    }␊
    ␊
    contract Foo19 {␊
      function __Foo19_init(uint x) internal onlyInitializing {␊
        }␊
    ␊
        function __Foo19_init_unchained(uint) internal onlyInitializing {}␊
    }␊
    ␊
    contract Foo20 is Foo19 {␊
      function __Foo20_init(uint x) internal onlyInitializing {␊
            __Foo19_init_unchained(x);␊
        }␊
    ␊
        function __Foo20_init_unchained(uint) internal onlyInitializing {}␊
    }␊
    ␊
    contract Foo21 is Foo20 {␊
      function __Foo21_init() internal onlyInitializing {␊
            __Foo19_init_unchained(4);␊
            __Foo20_init_unchained(4);␊
        }␊
    ␊
        function __Foo21_init_unchained() internal onlyInitializing {}␊
    }␊
    ␊
    contract Foo22 is Foo19 {␊
      function __Foo22_init(uint y) internal onlyInitializing {␊
            __Foo19_init_unchained(y + 1);␊
        }␊
    ␊
        function __Foo22_init_unchained(uint) internal onlyInitializing {}␊
    }␊
    ␊
    contract Foo23 is Foo9, Foo20 {␊
      function __Foo23_init(uint x, uint y) internal onlyInitializing {␊
            __Foo9_init_unchained(x, y);␊
            __Foo19_init_unchained(y);␊
            __Foo20_init_unchained(y);␊
        }␊
    ␊
        function __Foo23_init_unchained(uint, uint) internal onlyInitializing {}␊
    }␊
    ␊
    contract Foo24 is Foo23 {␊
        function __Foo24_init() internal onlyInitializing {␊
            __Foo9_init_unchained(1, 2);␊
            __Foo19_init_unchained(2);␊
            __Foo20_init_unchained(2);␊
            __Foo23_init_unchained(1, 2);␊
        }␊
    ␊
        function __Foo24_init_unchained() internal onlyInitializing {}␊
    }␊
    ␊
    contract Foo25 is Foo19 {␊
        function __Foo25_init() internal onlyInitializing {␊
            __Foo19_init_unchained(1+2);␊
        }␊
    ␊
        function __Foo25_init_unchained() internal onlyInitializing {}␊
    }␊
    ␊
    interface IFoo {␊
        function mint() external returns (uint);␊
    }␊
    ␊
    contract Foo26 is Foo19 {␊
        function __Foo26_init(IFoo t) internal onlyInitializing {␊
            __Foo19_init_unchained(t.mint());␊
        }␊
    ␊
        function __Foo26_init_unchained(IFoo) internal onlyInitializing {}␊
    }␊
    ␊
    contract Foo27 is Foo26 {␊
        function __Foo27_init(IFoo t) internal onlyInitializing {␊
            __Foo19_init_unchained(t.mint());␊
            __Foo26_init_unchained(t);␊
        }␊
    ␊
        function __Foo27_init_unchained(IFoo) internal onlyInitializing {}␊
    }␊
    ␊
    contract Foo28 {␊
        function __Foo28_init(uint x) internal onlyInitializing {␊
        }␊
    ␊
        function __Foo28_init_unchained(uint) internal onlyInitializing {}␊
    }␊
    ␊
    abstract contract Foo29 is Foo28 {␊
        function __Foo29_init(uint y) internal onlyInitializing {␊
        }␊
    ␊
        function __Foo29_init_unchained(uint) internal onlyInitializing {}␊
    }␊
    ␊
    abstract contract Foo30  is Foo28, Foo29 {␊
        function __Foo30_init(uint z) internal onlyInitializing {␊
            __Foo28_init_unchained(z);␊
        }␊
    ␊
        function __Foo30_init_unchained(uint) internal onlyInitializing {}␊
    }`

## fix new statement

> Snapshot 1

    `pragma solidity ^0.6;␊
    ␊
    contract Foo {␊
        function initialize(uint x) public virtual initializer {␊
            __Foo_init(x);␊
        }␊
        constructor(uint x) public {}␊
    }␊
    ␊
    contract Bar {␊
        function initialize() public virtual initializer {␊
            __Bar_init();␊
        }␊
    }␊
    ␊
    contract TransformNew {␊
        function test1() external {␊
            Foo foo;␊
            foo = new Foo();␊
            foo.initialize(1);␊
        }␊
    ␊
        function test2() external {␊
            Bar bar;␊
            bar = new Bar();␊
            bar.initialize();␊
        }␊
    }␊
    `

## add storage gaps

> Snapshot 1

    `pragma solidity ^0.6;␊
    ␊
    contract Foo0 {␊
    ␊
        /**␊
         * This empty reserved space is put in place to allow future versions to add new␊
         * variables without shifting down storage in the inheritance chain.␊
         * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps␊
         */␊
        uint256[50] private __gap;␊
    }␊
    ␊
    contract Foo1 {␊
        uint x;␊
    ␊
        /**␊
         * This empty reserved space is put in place to allow future versions to add new␊
         * variables without shifting down storage in the inheritance chain.␊
         * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps␊
         */␊
        uint256[49] private __gap;␊
    }␊
    ␊
    contract Foo2 {␊
        uint x;␊
        bool b1;␊
        bool b2;␊
    ␊
        /**␊
         * This empty reserved space is put in place to allow future versions to add new␊
         * variables without shifting down storage in the inheritance chain.␊
         * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps␊
         */␊
        uint256[48] private __gap;␊
    }␊
    `

## add requested public initializer

> Snapshot 1

    `pragma solidity ^0.6;␊
    ␊
    contract FooWithArgs {␊
        function initialize(uint x, uint y) public virtual initializer {␊
            __FooWithArgs_init(x, y);␊
        }␊
        constructor(uint x, uint y) public {}␊
    }␊
    ␊
    contract FooWithArgs2 {␊
        function initialize(uint x, uint y) public virtual initializer {␊
            __FooWithArgs2_init(x, y);␊
        }␊
        modifier hasModifierArguments(uint x) {␊
            _;␊
        }␊
        constructor(uint x, uint y) public hasModifierArguments(x) {}␊
    }␊
    `

## remove immutable

> Snapshot 1

    `pragma solidity ^0.6.5;␊
    ␊
    contract TransformImmutable {␊
        uint x;␊
        constructor() public {␊
            x = 3;␊
        }␊
    }␊
    `
