# Snapshot report for `src/transform-0.8.test.ts`

The actual snapshot is saved in `transform-0.8.test.ts.snap`.

Generated by [AVA](https://avajs.dev).

## rename parents in solidity 0.8

> Snapshot 1

    `// SPDX-License-Identifier: UNLICENSED␊
    pragma solidity ^0.8;␊
    ␊
    contract A {␊
        function foo() external virtual {}␊
    }␊
    ␊
    contract B is AUpgradeable {␊
        /// @inheritdoc AUpgradeable␊
        function foo() external override {}␊
    }␊
    ␊
    library L {␊
        struct S {␊
            uint x;␊
        }␊
    }␊
    ␊
    contract U {␊
        using LUpgradeable for LUpgradeable.S;␊
    }␊
    `

## correctly index when utf8 characters

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    ␊
    pragma solidity ^0.8.0;␊
    ␊
    library Strings {␊
        function toString(uint256) internal pure returns (string memory) {␊
            return "";␊
        }␊
    }␊
    ␊
    library ECDSA {␊
        enum RecoverError {␊
            InvalidSignature␊
        }␊
    ␊
        function tryRecover(bytes32, uint8, bytes32, bytes32) internal pure returns (address, RecoverError) {␊
            // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}␊
            return (address(0), RecoverError.InvalidSignature);␊
        }␊
    ␊
        function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {␊
            return keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n", StringsUpgradeable.toString(s.length), s));␊
        }␊
    }␊
    `

## preserves immutable if allowed

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    pragma solidity ^0.8.2;␊
    ␊
    contract T1 {␊
        function __T1_init() internal onlyInitializing {␊
            __T1_init_unchained();␊
        }␊
    ␊
        function __T1_init_unchained() internal onlyInitializing {␊
            a = 1;␊
            c = 3;␊
        }␊
        uint a;␊
        /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment␊
        uint immutable b = 4;␊
        uint c;␊
    }␊
    ␊
    contract T2 {␊
        uint a = 1;␊
        /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment␊
        uint immutable b = 4;␊
        uint c;␊
        /// @custom:oz-upgrades-unsafe-allow constructor␊
        constructor(uint _c) {␊
          c = _c;␊
        }␊
    }␊
    ␊
    abstract contract T3 is T2 {␊
        function __T3_init() internal onlyInitializing {␊
        }␊
    ␊
        function __T3_init_unchained() internal onlyInitializing {␊
        }␊
    }␊
    `

## custom contract size

> Snapshot 1

    `// SPDX-License-Identifier: UNLICENSED␊
    pragma solidity ^0.8;␊
    ␊
    struct HalfASlot {␊
      uint256 x;␊
      uint128 y;␊
    }␊
    ␊
    contract SizeDefault {␊
      /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment␊
      uint immutable w1 = block.number;␊
      /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment␊
      uint immutable w2 = block.timestamp;␊
      uint x; // slot 0 (after conversion to private)␊
      uint constant y = 1;␊
      uint224 z0; // slot 1␊
      uint256 z1; // slot 2␊
      uint32 z2; // slot 3␊
      HalfASlot s1; // slot 4+5␊
      HalfASlot s2; // slot 6+7␊
      uint32 z3; // slot 8␊
      uint32 z4; // slot 8␊
      uint32 z5; // slot 8␊
      uint64[5] a1; // slot 9+10␊
      uint64[3] a2; // slot 11␊
    ␊
      function __SizeDefault_init(uint _x) internal onlyInitializing {␊
            __SizeDefault_init_unchained(_x);␊
        }␊
    ␊
        function __SizeDefault_init_unchained(uint _x) internal onlyInitializing {␊
        x = _x;␊
      }␊
      // gap should be 38 = 50 - 12␊
    ␊
        /**␊
         * This empty reserved space is put in place to allow future versions to add new␊
         * variables without shifting down storage in the inheritance chain.␊
         * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps␊
         */␊
        uint256[38] private __gap;␊
    }␊
    ␊
    /// @custom:contract-size 128␊
    contract SizeOverride {␊
      /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment␊
      uint immutable w1 = block.number;␊
      /// @custom:oz-upgrades-unsafe-allow state-variable-immutable  state-variable-assignment␊
      uint immutable w2 = block.timestamp;␊
      uint x; // slot 0 (after conversion to private)␊
      uint constant y = 1;␊
      uint224 z0; // slot 1␊
      uint256 z1; // slot 2␊
      uint32 z2; // slot 3␊
      HalfASlot s1; // slot 4+5␊
      HalfASlot s2; // slot 6+7␊
      uint32 z3; // slot 8␊
      uint32 z4; // slot 8␊
      uint32 z5; // slot 8␊
      uint64[5] a1; // slot 9+10␊
      uint64[3] a2; // slot 11␊
    ␊
      function __SizeOverride_init(uint _x) internal onlyInitializing {␊
            __SizeOverride_init_unchained(_x);␊
        }␊
    ␊
        function __SizeOverride_init_unchained(uint _x) internal onlyInitializing {␊
        x = _x;␊
      }␊
      // gap should be 116 = 128 - 12␊
    ␊
        /**␊
         * This empty reserved space is put in place to allow future versions to add new␊
         * variables without shifting down storage in the inheritance chain.␊
         * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps␊
         */␊
        uint256[116] private __gap;␊
    }␊
    `
